页框回收算法(PFRA)：从用户态进程和内核高速缓存"窃取"页框的办法补充伙伴系统的空闲块列表
			目标就是获得页框并使之空闲。选取的页框肯定不是空闲的，不再伙伴系统的任何一个free_area数组中。

减少控制，使内核以最好的可行方式使用可用的RAM。
系统负载较低时，RAM的大部分由磁盘高速缓存占用，很少正在运行的进程可以获益
系统负载增加时，RAM的大部分由进程页占用，

PFRA处理的页框类型

映射页：该页映射了一个文件的某个部分，
匿名页：它属于一个进程的某匿名线性区


PFRA的总原则
1.首先释放"无害"页
2.将用户态进程的所有页定为可回收页
	除了锁定页，FPRA必须能窃得任何用户态进程页，包括匿名页。睡眠较长时间的进程将逐渐失去所有页框
3.同时取消引用一个共享页框的所有页表项的映射，就可以回收该共享页框
4.只回收"未用"页
	简化的最近最少使用置换算法，将页分为"在用"与"未用"



反向映射
	为了达到释放共享页框，Linux 2.6能快速定位指向同一页框的所有页表项

匿名页的反向映射
	匿名页通常是由几个线程共享的，最常见的情形就是创建新进程
为一个匿名线性区分配第一页时，内核创建新的anon_vma
struct anon_vma
{
spinlock_t lock;
	竞争条件下保护链表的自旋锁

struct list_head head;
	线性区描述符双向循环链表的头部
};

映射页的反向映射
访问相应映射页所在的线性区描述符，获得指向一个给定页框的页表项。反向映射的关键就是可以存放与给定页框有关的所有线性区描述符的数据结构
Linux 2.6依靠叫做"优先搜索树(priority search tree)"的结构来快速定位引用同一页框的所有线性区。
page->mapping->i_mmap---能很快检索搜索树的根

优先搜索树(PST)
PST中每一个区间相当于一个树的节点，由基索引(radix index)和堆索引(heap index)两个索引来标识。
基索引---区间的起始点
堆索引---区间的终点
PST是一个依赖于基索引的搜索树，并附加一个类堆索引，即一个节点的堆索引不会小于其子节点的堆索引。？？？？	


LRU链表
处理LRU链表的函数
/*include/linux/mm_inline.h*/
add_page_to_active_list()
	将页加入管理区的活动链表头部并递增管理区描述符的nr_active字段
add_page_to_inactive_list()
	将页加入管理区的活动链表头部并递增管理区描述符的nr_inactive字段
del_page_from_active_list()
	从管理区的活动链表中删除页并递减管理区描述符的nr_active字段
del_page_from_inactive_list()
	从管理区的活动链表中删除页并递减管理区描述符的nr_inactive字段
del_page_from_lru()
	检查页的PG_active标志，依据检查结果，将页从活动或非活动链表中删除，递减管理区描述符的nr_active或nr_inactive字段，若有必要，将PG_active清零
/*mm/swap.c*/
activate_page()
	检查PG_active标志，若未置位，将页移动到活动列表中，再将PG_active标志置位
lru_cache_add()
	若页不在LRU链表中，将PG_lru置位，把页插入管理区的非活动链表
lru_cache_add_active()
	若页不在LRU链表中，将PG_lru和PG_active置位，把页插入管理区的活动链表

最后两个函数并没有立刻把页移到LRU，而是将这些页聚集在pagevec临时数据结构中
struct pagevec {
        unsigned long nr;
        unsigned long cold;
        struct page *pages[PAGEVEC_SIZE];	PAGEVEC_SIZE = 14
};
只有在一个pagevec写满时，页才会真正移到LRU链表中。


/*mm/swap.c*/
mark_page_accedded()
	每当内核决定一个页是被用户态进程，文件系统层还是设备驱动程序引用时,内核把一个页标记为访问过。
调用函数的情形：
1.按需装入进程的一个匿名页(do_anonymous_page(),请求调页)
2.按需装入内存映射文件的一个页(filemap_nopage()，内存映射的请求调页)
3.按需装入IPC共享内存区的一个页(shmem_page(),IPC共享内存)
4.从文件读取数据页(do_generic_file_read(),从文件中读取数据)
5.换入一个页(do_swap_page(),换入页)
6.在页高速缓存中搜索一个缓冲区页(__find_get_block(),在页高速缓存中搜索块)

/*mm/rmap.c*/
page_referenced()
	PFRA扫描一页调用一次page_referenced()，如果PG_referenced或页表项中的某些Accessed标志置位，则函数返回1，否则返回0。

/*mm/vmscan.c*/
refill_inactive_zone()
	从活动链表到非活动页链表移动页
	shrink_zone()	/*对页高速缓存和用户态地址空间进行页回收*/
	     |-->refill_inactive_zone()

struct scan_control---存放着回收操作执行时的相关信息
{
unsigned long nr_to_scan;
	活动链表中待扫描的目标页数

unsigned long nr_scanned;
	当前迭代中扫描过的非活动页数

unsigned long nr_reclaimed;
	当前迭代中回收的页数

unsigned long nr_mapped;
	用户态地址空间引用的页数

int nr_to_reclaim;
	待回收的目标页数

unsigned int priority;
	扫描优先级，范围从12到0，低优先级表示扫描更多页
	用来控制refill_inactive_zone()扫描非活动链表中页的范围，低值表示更紧迫的优先级

unsigned int gfp_mask;
	调用进程传来的GFP掩码

int may_writepage;
	若置位，则允许脏页写到磁盘(只针对便携情形)
};


内存紧缺回收

内存分配失败时，激活内存紧缺回收。
/*fs/buffer.c*/
free_more_memory()
	分配VFS缓冲区或缓冲区首部
/*mm/vmscan.c*/
try_to_free_pages()
	从伙伴系统分配一个或多个页框

函数调用：
try_to_free_memory()	/*从伙伴系统分配一个或多个页框  mm/vmscan.c*/
	|---shrink_caches()	/*对zones链表中的每个管理区调用shrink_zone()*/      "即在try_to_free_pages()的第一迭代中不调用shrink_caches()"不明白
		|---shrink_zone()	/*从管理区非活动链表回收32页*/
			|---shrink_cache()  /*从管理区非活动链表取出一组页，把它们放入一个临时链表。到此为止，找到合适回收的候选页*/
				|---shrink_list()  /*尝试从page_list链表中回收这些页*/
					|---pageout()


shrink_list()的三种结果：
1.调用free_cold_page()，把页释放到管理区伙伴系统，因此被有效回收
2.页没有被回收，因此被重新插入page_list链表。但是函数假设不久还能回收该页。因此PG_active保持清0，这样页就被放回内存管理区的非活动链表。
3.页没有被回收，因此被重新插入page_list链表。但是，或是页正被使用，或函数假设近期不能回收该页。因此PG_active置位，这样页就被放回内存管理区的活动链表。


从目录项高速缓存回收页框
/*fs/dcache.c*/
shrink_dcache_memory()---目录项高速缓存的shrink函数
/*fs/inode.c*/
shrink_icache_memory()


周期回收
kswapd
cache_reap()
	被周期性地调用以便从slab分配器中回收未用的slab
	周期性(差不多两秒一次)地在预定事件工作队列中被调度。地址存放在per CPU变量reap_work的func字段，变量为work_struct类型



内存不足删除程序(OOM)
__alloc_pages
	|---out_of_memory()
		|---select_bad_process() /*在现有进程中选择一个"牺牲品"*/
		|---oom_kill_process()	/*删除进程*/


select_bad_process()选择进程的条件：
1.它必须拥有大量页框，从而可以释放处大量内存
2.删除它只损失少量工作成果
3.它应具有较低的静态优先级，用户通常给不太重要的进程赋予较低的优先级
4.它不应是有root特权的进程，特权进程的工作通常比较重要
5.它不应直接访问硬件块设备，因为硬件不能处在一个无法预知的状态
6.它不能是swapper(进程0)，init(进程1)和任何其他内核线程



交换标记
把交换标记(swap token)赋给系统中的单个进程，该标记可以使该进程免子页框回收，所以进程可以实质性的运行，而且即使内存十分的稀少，也有希望运行至结束

交换标记的具体实现形式是swap_token_mm内存描述符指针。当进程拥有交换标记时，swap_token_mm被设为进程内存描述符的地址。

交换标记在下面情况下不予考虑：
1.PFRA代表一个拥有交换标记的进程运行
2.PFRA达到页框回收的最难优先级

/*mm/thrash.c*/
grab_swap_token()---决定是否将交换标记赋给当前进程
对每个主缺页(major page fault)调用该函数的情形：
1.filemap_nopage()发现请求页不再页高速缓存中
2.do_swap_page()从交换区读入一个新页

赋予交换标记的条件：
1.上次调用grab_swap_token()后，至少已过了2s(swap_token_check)。
2.在上一次调用grab_swap_token()后，当前拥有交换标记的进程没再提出主缺页，或该进程拥有交换标记的时间超出swap_token_default_timeout个节拍
3.当前进程最近没有获得过交换标记

交换标记持有的时间最好长一点，甚至以分钟为单位，因为其目标就是允许进程完成其执行。通过/proc/sys/vm/swap_token_default_timeout或发出相应的sysctl()系统调用修改持有时间



----------------------------------------------------
交换
交换(swapping)用来为非映射页在磁盘上提供备份。
三类页必须由交换子系统处理：
1.属于进程匿名线性区(用户态堆栈和堆)的页
2.属于进程私有内存映射的页
3.属于IPC共享内存区的页


union swap_header {
struct {
	char reserved[PAGE_SIZE - 10];
                char magic[10];
        } magic;
        struct {
                char         bootbits[1024];
                unsigned int version;
                unsigned int last_page;
                unsigned int nr_badpages;
                unsigned int padding[125];
                unsigned int badpages[1];
        } info;
};